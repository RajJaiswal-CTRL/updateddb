<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Dashboard - Operations Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --secondary: #64748b;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --background: #f8fafc;
            --surface: #ffffff;
            --border: #e2e8f0;
            --text-primary: #0f172a;
            --text-secondary: #64748b;
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .app-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .app-header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .app-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .title-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.25rem;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            color: #15803d;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }

        /* Upload Section */
        .upload-section {
            text-align: center;
            padding: 4rem 2rem;
        }

        .upload-container {
            max-width: 600px;
            margin: 0 auto;
        }

        .upload-area {
            background: var(--surface);
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 3rem 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: var(--primary);
            background: #f0f9ff;
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.7;
        }

        .upload-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .upload-subtitle {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .upload-formats {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .format-badge {
            padding: 0.25rem 0.75rem;
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        /* Dashboard Section */
        .dashboard-section {
            display: none;
            animation: fadeIn 0.4s ease;
        }

        .dashboard-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Toolbar */
        .toolbar {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow);
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .file-info {
            flex: 1;
            min-width: 200px;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border-radius: 8px;
            border: 1px solid #bfdbfe;
        }

        .file-icon {
            font-size: 1.5rem;
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .file-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Buttons */
        .btn {
            padding: 0.625rem 1.25rem;
            border: none;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
            font-family: 'Inter', sans-serif;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--background);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1.25rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
            border: 1px solid var(--border);
        }

        .stat-card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .stat-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .stat-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .stat-icon.blue { background: #dbeafe; }
        .stat-icon.green { background: #d1fae5; }
        .stat-icon.purple { background: #e9d5ff; }
        .stat-icon.orange { background: #fed7aa; }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
        }

        .stat-change {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        /* Section Container */
        .section {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .section-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 1.5rem;
        }

        .chart-card {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .chart-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .chart-type-badge {
            padding: 0.25rem 0.625rem;
            background: var(--background);
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        /* Table Controls */
        .table-controls {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.25rem;
            flex-wrap: wrap;
        }

        .search-input {
            flex: 1;
            min-width: 250px;
            padding: 0.625rem 1rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.875rem;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .filter-select {
            padding: 0.625rem 1rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.875rem;
            font-family: 'Inter', sans-serif;
            background: var(--surface);
            cursor: pointer;
        }

        /* Table */
        .table-container {
            overflow: hidden;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .table-scroll {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 600px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            background: var(--primary);
            color: white;
            padding: 0.875rem 1rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: var(--primary-dark);
        }

        th .sort-indicator {
            margin-left: 0.25rem;
            font-size: 0.625rem;
            opacity: 0.7;
        }

        .type-badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            font-size: 0.625rem;
            font-weight: 600;
            margin-left: 0.375rem;
        }

        .type-badge.numeric { background: #dbeafe; color: #1e40af; }
        .type-badge.text { background: #fce7f3; color: #9f1239; }
        .type-badge.date { background: #d1fae5; color: #166534; }
        .type-badge.formula { background: #fef3c7; color: #92400e; }
        .type-badge.categorical { background: #e9d5ff; color: #6b21a8; }

        td {
            padding: 0.875rem 1rem;
            border-bottom: 1px solid var(--border);
            color: var(--text-primary);
            white-space: nowrap;
        }

        tbody tr {
            transition: background 0.15s ease;
        }

        tbody tr:hover {
            background: var(--background);
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        .cell-formula {
            font-family: 'Courier New', monospace;
            font-size: 0.8125rem;
            color: var(--warning);
        }

        .cell-numeric {
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .cell-empty {
            color: var(--text-secondary);
            font-style: italic;
            opacity: 0.5;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1.25rem;
            padding-top: 1.25rem;
            border-top: 1px solid var(--border);
        }

        .pagination-info {
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .pagination-controls {
            display: flex;
            gap: 0.5rem;
        }

        .page-btn {
            padding: 0.5rem 0.875rem;
            border: 1px solid var(--border);
            background: var(--surface);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .page-btn:hover:not(:disabled) {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .page-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .page-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border-radius: 16px;
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1);
        }

        .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border);
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .modal-subtitle {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-footer {
            padding: 1.5rem 2rem;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        /* Column Selector */
        .column-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 1rem;
        }

        .column-option {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .column-option:hover {
            border-color: var(--primary);
            background: #f0f9ff;
        }

        .column-option.selected {
            border-color: var(--primary);
            background: #eff6ff;
        }

        .column-option.selected::before {
            content: '‚úì';
            float: right;
            color: var(--primary);
            font-weight: 700;
        }

        .column-option-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            font-size: 0.875rem;
        }

        .column-option-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Filter Builder */
        .filter-row {
            display: grid;
            grid-template-columns: 1fr 140px 1fr auto;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            align-items: center;
        }

        .filter-input {
            padding: 0.625rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.875rem;
            font-family: 'Inter', sans-serif;
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin: 1rem auto 0.5rem;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            background: var(--primary);
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--surface);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            border-left: 4px solid var(--primary);
            display: none;
            align-items: center;
            gap: 0.75rem;
            max-width: 400px;
            z-index: 3000;
            animation: slideUp 0.3s ease;
        }

        .toast.active {
            display: flex;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .toast.success { border-left-color: var(--success); }
        .toast.error { border-left-color: var(--danger); }
        .toast.warning { border-left-color: var(--warning); }
        .toast.info { border-left-color: var(--primary); }

        .toast-icon {
            font-size: 1.25rem;
        }

        .toast-message {
            flex: 1;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
        }

        .empty-icon {
            font-size: 3rem;
            opacity: 0.3;
            margin-bottom: 1rem;
        }

        .empty-text {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* Scrollbar Styling */
        .table-scroll::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .table-scroll::-webkit-scrollbar-track {
            background: var(--background);
        }

        .table-scroll::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .table-scroll::-webkit-scrollbar-thumb:hover {
            background: var(--secondary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-content {
                padding: 1rem;
            }

            .app-header {
                padding: 1rem;
            }

            .header-content {
                flex-direction: column;
                gap: 1rem;
                align-items: flex-start;
            }

            .toolbar {
                flex-direction: column;
            }

            .file-info {
                width: 100%;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .filter-row {
                grid-template-columns: 1fr;
            }

            .pagination {
                flex-direction: column;
                gap: 1rem;
            }

            .table-scroll {
                max-height: 400px;
            }
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="header-content">
                <div class="app-title">
                    <div class="title-icon">üìä</div>
                    <span>Data Dashboard</span>
                </div>
                <div class="status-badge" id="statusBadge" style="display: none;">
                    <div class="status-dot"></div>
                    <span>Live Monitor</span>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Upload Section -->
            <div id="uploadSection" class="upload-section">
                <div class="upload-container">
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">üìÅ</div>
                        <div class="upload-title">Upload Your Data</div>
                        <div class="upload-subtitle">Drag and drop or click to browse</div>
                        <div class="upload-formats">
                            <span class="format-badge">CSV</span>
                            <span class="format-badge">XLSX</span>
                            <span class="format-badge">XLS</span>
                        </div>
                        <input type="file" id="fileInput" accept=".csv,.xlsx,.xls">
                    </div>
                </div>
            </div>

            <!-- Dashboard Section -->
            <div id="dashboardSection" class="dashboard-section">
                <!-- Toolbar -->
                <div class="toolbar">
                    <div class="file-info" id="fileInfo">
                        <div class="file-icon">üìÑ</div>
                        <div class="file-details">
                            <div class="file-name" id="fileName">-</div>
                            <div class="file-meta" id="fileMeta">-</div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="uploadNew()">
                        <span>üì§</span> Upload New
                    </button>
                    <button class="btn btn-warning" onclick="openChartBuilder()">
                        <span>üìä</span> Add Charts
                    </button>
                    <button class="btn btn-secondary" onclick="openFilterModal()">
                        <span>üîç</span> Filter
                    </button>
                    <button class="btn btn-success" onclick="exportData()">
                        <span>üíæ</span> Export
                    </button>
                    <button class="btn btn-secondary" onclick="refreshData()">
                        <span>üîÑ</span> Refresh
                    </button>
                </div>

                <!-- Statistics -->
                <div id="statsGrid" class="stats-grid"></div>

                <!-- Charts Section -->
                <div id="chartsSection" class="section" style="display: none;">
                    <div class="section-header">
                        <div class="section-title">
                            <span>üìà</span> Analytics
                        </div>
                        <button class="btn btn-secondary" onclick="clearCharts()">Clear All</button>
                    </div>
                    <div id="chartsGrid" class="charts-grid"></div>
                </div>

                <!-- Data Table Section -->
                <div class="section">
                    <div class="section-header">
                        <div class="section-title">
                            <span>üóÇÔ∏è</span> Data Table
                        </div>
                    </div>

                    <div class="table-controls">
                        <input 
                            type="text" 
                            class="search-input" 
                            id="searchInput" 
                            placeholder="üîç Search across all columns..."
                            oninput="handleSearch(this.value)"
                        >
                        <select class="filter-select" id="rowsPerPage" onchange="changeRowsPerPage()">
                            <option value="25">25 rows</option>
                            <option value="50" selected>50 rows</option>
                            <option value="100">100 rows</option>
                            <option value="250">250 rows</option>
                            <option value="500">500 rows</option>
                            <option value="-1">All rows</option>
                        </select>
                    </div>

                    <div class="table-container">
                        <div class="table-scroll">
                            <table id="dataTable">
                                <thead id="tableHead"></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <div id="pagination" class="pagination"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Chart Builder Modal -->
    <div id="chartModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Create Visualizations</div>
                <div class="modal-subtitle">Select columns to visualize (supports numeric and categorical data)</div>
            </div>
            <div class="modal-body">
                <div id="columnGrid" class="column-grid"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeChartModal()">Cancel</button>
                <button class="btn btn-primary" onclick="generateCharts()">Generate Charts</button>
            </div>
        </div>
    </div>

    <!-- Filter Modal -->
    <div id="filterModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Filter Data</div>
                <div class="modal-subtitle">Apply filters to refine your data view</div>
            </div>
            <div class="modal-body">
                <div id="filterContainer"></div>
                <button class="btn btn-secondary" onclick="addFilter()" style="margin-top: 1rem;">
                    <span>+</span> Add Filter
                </button>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="clearAllFilters()">Clear All</button>
                <button class="btn btn-secondary" onclick="closeFilterModal()">Cancel</button>
                <button class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-text" id="loadingText">Processing...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="progressBar" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
        <div class="toast-icon" id="toastIcon"></div>
        <div class="toast-message" id="toastMessage"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script>
        // Application State
        const AppState = {
            rawData: [],
            displayData: [],
            columns: [],
            columnMetadata: {},
            currentPage: 1,
            rowsPerPage: 50,
            sortConfig: { column: null, direction: 'asc' },
            filters: [],
            selectedChartColumns: new Set(),
            charts: [],
            fileName: '',
            fileSize: 0,
            lastUpdated: null
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
        });

        function setupEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                if (e.dataTransfer.files.length) {
                    processFile(e.dataTransfer.files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    processFile(e.target.files[0]);
                }
            });
        }

        // File Processing
        async function processFile(file) {
            AppState.fileName = file.name;
            AppState.fileSize = file.size;
            
            showLoading('Analyzing file structure...', 10);

            try {
                const extension = file.name.split('.').pop().toLowerCase();
                
                if (extension === 'csv') {
                    await processCSV(file);
                } else if (extension === 'xlsx' || extension === 'xls') {
                    await processExcel(file);
                } else {
                    throw new Error('Unsupported file format');
                }
            } catch (error) {
                hideLoading();
                showToast('Error: ' + error.message, 'error');
                console.error('File processing error:', error);
            }
        }

        async function processCSV(file) {
            updateProgress(30, 'Reading CSV file...');
            
            const text = await file.text();
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            
            if (lines.length < 2) {
                throw new Error('File must contain header and at least one data row');
            }

            updateProgress(50, 'Parsing data structure...');

            // Advanced CSV parsing with quote handling
            const parseCSVLine = (line) => {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const next = line[i + 1];
                    
                    if (char === '"') {
                        if (inQuotes && next === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            };

            // Extract headers
            const headers = parseCSVLine(lines[0]);
            AppState.columns = headers.map((h, i) => h || `Column_${i + 1}`);

            updateProgress(70, 'Processing rows...');

            // Parse data rows
            AppState.rawData = [];
            const totalRows = lines.length - 1;
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                const row = {};
                let hasData = false;

                AppState.columns.forEach((col, idx) => {
                    const value = values[idx] || '';
                    row[col] = value;
                    if (value) hasData = true;
                });

                if (hasData) {
                    AppState.rawData.push(row);
                }

                // Update progress periodically
                if (i % 1000 === 0) {
                    updateProgress(70 + (i / totalRows) * 20, `Processing row ${i.toLocaleString()} of ${totalRows.toLocaleString()}...`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            await finalizeDataLoad();
        }

        async function processExcel(file) {
            updateProgress(30, 'Reading Excel file...');
            
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, {
                type: 'array',
                cellFormula: true,
                cellDates: true,
                cellNF: false,
                cellText: false,
                raw: false,
                dense: false
            });

            updateProgress(50, 'Extracting sheet data...');

            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const range = XLSX.utils.decode_range(firstSheet['!ref'] || 'A1');

            // Extract headers
            AppState.columns = [];
            for (let col = range.s.c; col <= range.e.c; col++) {
                const cellAddr = XLSX.utils.encode_cell({ r: range.s.r, c: col });
                const cell = firstSheet[cellAddr];
                AppState.columns.push(cell ? String(cell.v).trim() : `Column_${col + 1}`);
            }

            updateProgress(70, 'Processing data rows...');

            // Extract data rows
            AppState.rawData = [];
            const totalRows = range.e.r - range.s.r;

            for (let row = range.s.r + 1; row <= range.e.r; row++) {
                const rowData = {};
                let hasData = false;

                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddr = XLSX.utils.encode_cell({ r: row, c: col });
                    const cell = firstSheet[cellAddr];
                    const colName = AppState.columns[col - range.s.c];

                    let value = '';
                    if (cell) {
                        // Preserve formulas
                        if (cell.f) {
                            value = `=${cell.f}`;
                        } else if (cell.w) {
                            value = cell.w; // Formatted value
                        } else if (cell.v !== undefined) {
                            value = String(cell.v);
                        }
                        hasData = true;
                    }

                    rowData[colName] = value;
                }

                if (hasData) {
                    AppState.rawData.push(rowData);
                }

                // Update progress periodically
                if (row % 1000 === 0) {
                    const progress = ((row - range.s.r) / totalRows) * 20;
                    updateProgress(70 + progress, `Processing row ${row - range.s.r} of ${totalRows}...`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            await finalizeDataLoad();
        }

        async function finalizeDataLoad() {
            updateProgress(90, 'Analyzing data types...');
            
            await analyzeColumns();
            
            updateProgress(95, 'Initializing dashboard...');
            
            AppState.displayData = [...AppState.rawData];
            AppState.lastUpdated = new Date();
            
            await initializeDashboard();
            
            updateProgress(100, 'Complete!');
            
            setTimeout(() => {
                hideLoading();
                showToast(`Loaded ${AppState.rawData.length.toLocaleString()} rows with ${AppState.columns.length} columns`, 'success');
            }, 500);
        }

        async function analyzeColumns() {
            AppState.columnMetadata = {};

            for (const column of AppState.columns) {
                const values = AppState.rawData
                    .map(row => row[column])
                    .filter(v => v !== null && v !== undefined && String(v).trim() !== '');

                if (values.length === 0) {
                    AppState.columnMetadata[column] = {
                        type: 'empty',
                        unique: 0,
                        hasFormulas: false,
                        sample: []
                    };
                    continue;
                }

                const unique = new Set(values).size;
                const hasFormulas = values.some(v => String(v).startsWith('='));
                const sample = values.slice(0, 5);

                // Determine type
                let type = 'text';
                
                if (hasFormulas) {
                    type = 'formula';
                } else {
                    const numericCount = values.filter(v => !isNaN(v) && v !== '').length;
                    const numericRatio = numericCount / values.length;

                    if (numericRatio > 0.8) {
                        type = 'numeric';
                    } else if (unique <= Math.min(20, values.length * 0.3)) {
                        type = 'categorical';
                    } else if (values.some(v => isDateLike(v))) {
                        type = 'date';
                    }
                }

                AppState.columnMetadata[column] = {
                    type,
                    unique,
                    hasFormulas,
                    sample,
                    totalValues: values.length,
                    emptyCount: AppState.rawData.length - values.length
                };
            }
        }

        function isDateLike(value) {
            const str = String(value);
            const datePatterns = [
                /^\d{4}-\d{2}-\d{2}$/,
                /^\d{2}\/\d{2}\/\d{4}$/,
                /^\d{2}-\d{2}-\d{4}$/,
                /^\d{1,2}\/\d{1,2}\/\d{2,4}$/,
                /^\d{4}\/\d{2}\/\d{2}$/
            ];
            return datePatterns.some(pattern => pattern.test(str));
        }

        async function initializeDashboard() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('dashboardSection').classList.add('active');
            document.getElementById('statusBadge').style.display = 'flex';

            // Update file info
            const fileSizeMB = (AppState.fileSize / (1024 * 1024)).toFixed(2);
            document.getElementById('fileName').textContent = AppState.fileName;
            document.getElementById('fileMeta').textContent = 
                `${AppState.rawData.length.toLocaleString()} rows ‚Ä¢ ${AppState.columns.length} columns ‚Ä¢ ${fileSizeMB} MB`;

            renderStats();
            renderTable();
        }

        function renderStats() {
            const container = document.getElementById('statsGrid');
            
            const numericCols = Object.values(AppState.columnMetadata).filter(m => m.type === 'numeric').length;
            const categoricalCols = Object.values(AppState.columnMetadata).filter(m => m.type === 'categorical').length;
            const formulaCols = Object.values(AppState.columnMetadata).filter(m => m.type === 'formula').length;

            container.innerHTML = `
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-label">Total Records</div>
                        <div class="stat-icon blue">üìä</div>
                    </div>
                    <div class="stat-value">${AppState.rawData.length.toLocaleString()}</div>
                    <div class="stat-change">Active dataset</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-label">Columns</div>
                        <div class="stat-icon green">üìã</div>
                    </div>
                    <div class="stat-value">${AppState.columns.length}</div>
                    <div class="stat-change">${numericCols} numeric ‚Ä¢ ${categoricalCols} categorical</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-label">Data Quality</div>
                        <div class="stat-icon purple">‚úì</div>
                    </div>
                    <div class="stat-value">${calculateDataQuality()}%</div>
                    <div class="stat-change">Completeness score</div>
                </div>
                
                ${formulaCols > 0 ? `
                <div class="stat-card">
                    <div class="stat-header">
                        <div class="stat-label">Formulas</div>
                        <div class="stat-icon orange">∆íx</div>
                    </div>
                    <div class="stat-value">${formulaCols}</div>
                    <div class="stat-change">Calculated columns</div>
                </div>
                ` : ''}
            `;
        }

        function calculateDataQuality() {
            let totalCells = AppState.rawData.length * AppState.columns.length;
            let filledCells = 0;

            AppState.rawData.forEach(row => {
                AppState.columns.forEach(col => {
                    if (row[col] && String(row[col]).trim()) {
                        filledCells++;
                    }
                });
            });

            return Math.round((filledCells / totalCells) * 100);
        }

        function renderTable() {
            const thead = document.getElementById('tableHead');
            const tbody = document.getElementById('tableBody');

            // Render headers
            thead.innerHTML = `
                <tr>
                    ${AppState.columns.map(col => {
                        const meta = AppState.columnMetadata[col];
                        let badge = '';
                        
                        switch (meta.type) {
                            case 'numeric':
                                badge = '<span class="type-badge numeric">123</span>';
                                break;
                            case 'categorical':
                                badge = '<span class="type-badge categorical">ABC</span>';
                                break;
                            case 'date':
                                badge = '<span class="type-badge date">üìÖ</span>';
                                break;
                            case 'formula':
                                badge = '<span class="type-badge formula">fx</span>';
                                break;
                            case 'text':
                                badge = '<span class="type-badge text">TXT</span>';
                                break;
                        }

                        const sortIndicator = AppState.sortConfig.column === col 
                            ? `<span class="sort-indicator">${AppState.sortConfig.direction === 'asc' ? '‚ñ≤' : '‚ñº'}</span>`
                            : '<span class="sort-indicator" style="opacity: 0.3;">‚áÖ</span>';

                        return `<th onclick="sortTable('${col}')">${col}${badge}${sortIndicator}</th>`;
                    }).join('')}
                </tr>
            `;

            // Calculate pagination
            const totalRows = AppState.displayData.length;
            const totalPages = AppState.rowsPerPage === -1 ? 1 : Math.ceil(totalRows / AppState.rowsPerPage);
            AppState.currentPage = Math.min(AppState.currentPage, Math.max(1, totalPages));

            const startIdx = AppState.rowsPerPage === -1 ? 0 : (AppState.currentPage - 1) * AppState.rowsPerPage;
            const endIdx = AppState.rowsPerPage === -1 ? totalRows : Math.min(startIdx + AppState.rowsPerPage, totalRows);
            const pageData = AppState.displayData.slice(startIdx, endIdx);

            // Render rows
            if (pageData.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="${AppState.columns.length}">
                            <div class="empty-state">
                                <div class="empty-icon">üì≠</div>
                                <div class="empty-text">No data to display</div>
                            </div>
                        </td>
                    </tr>
                `;
            } else {
                tbody.innerHTML = pageData.map(row => `
                    <tr>
                        ${AppState.columns.map(col => {
                            const value = row[col];
                            const meta = AppState.columnMetadata[col];
                            
                            if (!value || String(value).trim() === '') {
                                return '<td class="cell-empty">‚Äî</td>';
                            }
                            
                            if (String(value).startsWith('=')) {
                                return `<td class="cell-formula">${value}</td>`;
                            }
                            
                            if (meta.type === 'numeric') {
                                return `<td class="cell-numeric">${value}</td>`;
                            }
                            
                            return `<td>${value}</td>`;
                        }).join('')}
                    </tr>
                `).join('');
            }

            renderPagination(totalPages, totalRows, startIdx, endIdx);
        }

        function renderPagination(totalPages, totalRows, startIdx, endIdx) {
            const container = document.getElementById('pagination');

            if (AppState.rowsPerPage === -1) {
                container.innerHTML = `
                    <div class="pagination-info">Showing all ${totalRows.toLocaleString()} rows</div>
                    <div class="pagination-controls"></div>
                `;
                return;
            }

            const start = startIdx + 1;
            const end = endIdx;
            const current = AppState.currentPage;

            // Generate page numbers to show
            let pagesToShow = [];
            if (totalPages <= 7) {
                pagesToShow = Array.from({ length: totalPages }, (_, i) => i + 1);
            } else {
                if (current <= 4) {
                    pagesToShow = [1, 2, 3, 4, 5, '...', totalPages];
                } else if (current >= totalPages - 3) {
                    pagesToShow = [1, '...', totalPages - 4, totalPages - 3, totalPages - 2, totalPages - 1, totalPages];
                } else {
                    pagesToShow = [1, '...', current - 1, current, current + 1, '...', totalPages];
                }
            }

            container.innerHTML = `
                <div class="pagination-info">
                    Showing ${start.toLocaleString()} - ${end.toLocaleString()} of ${totalRows.toLocaleString()} rows
                </div>
                <div class="pagination-controls">
                    <button class="page-btn" onclick="changePage(${current - 1})" ${current === 1 ? 'disabled' : ''}>
                        ‚óÄ Previous
                    </button>
                    ${pagesToShow.map(page => {
                        if (page === '...') {
                            return '<span style="padding: 0 0.5rem; color: var(--text-secondary);">...</span>';
                        }
                        return `
                            <button 
                                class="page-btn ${page === current ? 'active' : ''}" 
                                onclick="changePage(${page})"
                            >
                                ${page}
                            </button>
                        `;
                    }).join('')}
                    <button class="page-btn" onclick="changePage(${current + 1})" ${current >= totalPages ? 'disabled' : ''}>
                        Next ‚ñ∂
                    </button>
                </div>
            `;
        }

        function changePage(page) {
            AppState.currentPage = page;
            renderTable();
        }

        function changeRowsPerPage() {
            AppState.rowsPerPage = parseInt(document.getElementById('rowsPerPage').value);
            AppState.currentPage = 1;
            renderTable();
        }

        function sortTable(column) {
            if (AppState.sortConfig.column === column) {
                AppState.sortConfig.direction = AppState.sortConfig.direction === 'asc' ? 'desc' : 'asc';
            } else {
                AppState.sortConfig.column = column;
                AppState.sortConfig.direction = 'asc';
            }

            AppState.displayData.sort((a, b) => {
                let aVal = a[column] || '';
                let bVal = b[column] || '';

                // Handle numeric sorting
                if (!isNaN(aVal) && !isNaN(bVal) && aVal !== '' && bVal !== '') {
                    aVal = parseFloat(aVal);
                    bVal = parseFloat(bVal);
                    return AppState.sortConfig.direction === 'asc' ? aVal - bVal : bVal - aVal;
                }

                // String sorting
                const compare = String(aVal).localeCompare(String(bVal));
                return AppState.sortConfig.direction === 'asc' ? compare : -compare;
            });

            renderTable();
        }

        function handleSearch(searchTerm) {
            if (!searchTerm.trim()) {
                AppState.displayData = AppState.filters.length > 0 
                    ? applyFiltersToData(AppState.rawData)
                    : [...AppState.rawData];
            } else {
                const term = searchTerm.toLowerCase();
                const baseData = AppState.filters.length > 0 
                    ? applyFiltersToData(AppState.rawData)
                    : AppState.rawData;

                AppState.displayData = baseData.filter(row =>
                    AppState.columns.some(col =>
                        String(row[col] || '').toLowerCase().includes(term)
                    )
                );
            }

            AppState.currentPage = 1;
            renderTable();
        }

        // Chart Builder
        function openChartBuilder() {
            document.getElementById('chartModal').classList.add('active');
            
            const grid = document.getElementById('columnGrid');
            const chartableColumns = AppState.columns.filter(col => {
                const meta = AppState.columnMetadata[col];
                return ['numeric', 'categorical'].includes(meta.type);
            });

            grid.innerHTML = chartableColumns.map(col => {
                const meta = AppState.columnMetadata[col];
                const selected = AppState.selectedChartColumns.has(col);
                
                return `
                    <div class="column-option ${selected ? 'selected' : ''}" onclick="toggleChartColumn('${col}')">
                        <div class="column-option-name">${col}</div>
                        <div class="column-option-meta">
                            ${meta.type === 'numeric' ? 'üìä Numeric' : 'üìà Categorical'} ‚Ä¢ 
                            ${meta.unique} unique values
                        </div>
                    </div>
                `;
            }).join('');

            if (chartableColumns.length === 0) {
                grid.innerHTML = '<div class="empty-state"><div class="empty-text">No chartable columns found</div></div>';
            }
        }

        function toggleChartColumn(column) {
            if (AppState.selectedChartColumns.has(column)) {
                AppState.selectedChartColumns.delete(column);
            } else {
                AppState.selectedChartColumns.add(column);
            }
            openChartBuilder();
        }

        function generateCharts() {
            if (AppState.selectedChartColumns.size === 0) {
                showToast('Please select at least one column', 'warning');
                return;
            }

            closeChartModal();

            // Clear existing charts
            AppState.charts.forEach(chart => chart.destroy());
            AppState.charts = [];

            const container = document.getElementById('chartsGrid');
            const section = document.getElementById('chartsSection');
            
            container.innerHTML = '';
            section.style.display = 'block';

            AppState.selectedChartColumns.forEach(column => {
                const chartId = `chart_${column.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const meta = AppState.columnMetadata[column];
                
                const chartCard = document.createElement('div');
                chartCard.className = 'chart-card';
                chartCard.innerHTML = `
                    <div class="chart-header">
                        <div class="chart-title">${column}</div>
                        <div class="chart-type-badge">${meta.type}</div>
                    </div>
                    <canvas id="${chartId}"></canvas>
                `;
                container.appendChild(chartCard);

                setTimeout(() => createChart(column, chartId), 100);
            });

            showToast(`Generated ${AppState.selectedChartColumns.size} chart(s)`, 'success');
        }

        function createChart(column, chartId) {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const meta = AppState.columnMetadata[column];
            const values = AppState.displayData
                .map(row => row[column])
                .filter(v => v !== null && v !== undefined && String(v).trim() !== '');

            let config;

            if (meta.type === 'numeric') {
                // Create histogram
                const numValues = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
                const min = Math.min(...numValues);
                const max = Math.max(...numValues);
                const binCount = Math.min(20, Math.ceil(Math.sqrt(numValues.length)));
                const binSize = (max - min) / binCount;

                const bins = Array(binCount).fill(0);
                const labels = [];

                for (let i = 0; i < binCount; i++) {
                    const start = min + (i * binSize);
                    const end = start + binSize;
                    labels.push(`${start.toFixed(1)}`);
                }

                numValues.forEach(v => {
                    let binIndex = Math.floor((v - min) / binSize);
                    binIndex = Math.min(binIndex, binCount - 1);
                    bins[binIndex]++;
                });

                config = {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Frequency',
                            data: bins,
                            backgroundColor: 'rgba(37, 99, 235, 0.7)',
                            borderColor: 'rgba(37, 99, 235, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title: (items) => {
                                        const idx = items[0].dataIndex;
                                        const start = min + (idx * binSize);
                                        const end = start + binSize;
                                        return `Range: ${start.toFixed(2)} - ${end.toFixed(2)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Count' }
                            },
                            x: {
                                title: { display: true, text: column }
                            }
                        }
                    }
                };
            } else {
                // Create bar/pie chart for categorical
                const counts = {};
                values.forEach(v => {
                    counts[v] = (counts[v] || 0) + 1;
                });

                const sorted = Object.entries(counts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 15);

                const chartType = sorted.length <= 7 ? 'doughnut' : 'bar';

                config = {
                    type: chartType,
                    data: {
                        labels: sorted.map(([label]) => label),
                        datasets: [{
                            label: column,
                            data: sorted.map(([, count]) => count),
                            backgroundColor: generateChartColors(sorted.length),
                            borderWidth: chartType === 'doughnut' ? 0 : 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: chartType === 'doughnut',
                                position: 'bottom'
                            }
                        },
                        scales: chartType === 'bar' ? {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Count' }
                            }
                        } : {}
                    }
                };
            }

            const chart = new Chart(ctx, config);
            AppState.charts.push(chart);
        }

        function generateChartColors(count) {
            const colors = [
                'rgba(37, 99, 235, 0.7)',
                'rgba(16, 185, 129, 0.7)',
                'rgba(245, 158, 11, 0.7)',
                'rgba(239, 68, 68, 0.7)',
                'rgba(139, 92, 246, 0.7)',
                'rgba(236, 72, 153, 0.7)',
                'rgba(14, 165, 233, 0.7)',
                'rgba(34, 197, 94, 0.7)'
            ];
            return Array.from({ length: count }, (_, i) => colors[i % colors.length]);
        }

        function clearCharts() {
            AppState.charts.forEach(chart => chart.destroy());
            AppState.charts = [];
            AppState.selectedChartColumns.clear();
            document.getElementById('chartsSection').style.display = 'none';
            showToast('Charts cleared', 'info');
        }

        function closeChartModal() {
            document.getElementById('chartModal').classList.remove('active');
        }

        // Filter Modal
        function openFilterModal() {
            document.getElementById('filterModal').classList.add('active');
            renderFilters();
        }

        function renderFilters() {
            const container = document.getElementById('filterContainer');
            
            if (AppState.filters.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-text">No filters applied. Click "Add Filter" to start.</div></div>';
                return;
            }

            container.innerHTML = AppState.filters.map((filter, idx) => `
                <div class="filter-row">
                    <select class="filter-input" onchange="updateFilter(${idx}, 'column', this.value)">
                        ${AppState.columns.map(col => 
                            `<option value="${col}" ${filter.column === col ? 'selected' : ''}>${col}</option>`
                        ).join('')}
                    </select>
                    <select class="filter-input" onchange="updateFilter(${idx}, 'operator', this.value)">
                        <option value="equals" ${filter.operator === 'equals' ? 'selected' : ''}>Equals</option>
                        <option value="contains" ${filter.operator === 'contains' ? 'selected' : ''}>Contains</option>
                        <option value="startsWith" ${filter.operator === 'startsWith' ? 'selected' : ''}>Starts with</option>
                        <option value="endsWith" ${filter.operator === 'endsWith' ? 'selected' : ''}>Ends with</option>
                        <option value="greater" ${filter.operator === 'greater' ? 'selected' : ''}>Greater than</option>
                        <option value="less" ${filter.operator === 'less' ? 'selected' : ''}>Less than</option>
                        <option value="notEmpty" ${filter.operator === 'notEmpty' ? 'selected' : ''}>Not empty</option>
                    </select>
                    <input 
                        type="text" 
                        class="filter-input" 
                        value="${filter.value || ''}"
                        onchange="updateFilter(${idx}, 'value', this.value)"
                        ${filter.operator === 'notEmpty' ? 'disabled' : ''}
                        placeholder="Value"
                    >
                    <button class="btn btn-danger" onclick="removeFilter(${idx})">‚úï</button>
                </div>
            `).join('');
        }

        function addFilter() {
            AppState.filters.push({
                column: AppState.columns[0],
                operator: 'contains',
                value: ''
            });
            renderFilters();
        }

        function updateFilter(idx, field, value) {
            AppState.filters[idx][field] = value;
            if (field === 'operator' && value === 'notEmpty') {
                AppState.filters[idx].value = '';
            }
            renderFilters();
        }

        function removeFilter(idx) {
            AppState.filters.splice(idx, 1);
            renderFilters();
        }

        function applyFilters() {
            AppState.displayData = applyFiltersToData(AppState.rawData);
            AppState.currentPage = 1;
            
            // Reapply search if active
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm) {
                handleSearch(searchTerm);
            } else {
                renderTable();
            }

            closeFilterModal();
            showToast(`Applied ${AppState.filters.length} filter(s). Showing ${AppState.displayData.length} rows`, 'success');
        }

        function applyFiltersToData(data) {
            return data.filter(row => {
                return AppState.filters.every(filter => {
                    const cellValue = String(row[filter.column] || '').toLowerCase();
                    const filterValue = String(filter.value).toLowerCase();

                    switch (filter.operator) {
                        case 'equals':
                            return cellValue === filterValue;
                        case 'contains':
                            return cellValue.includes(filterValue);
                        case 'startsWith':
                            return cellValue.startsWith(filterValue);
                        case 'endsWith':
                            return cellValue.endsWith(filterValue);
                        case 'greater':
                            return parseFloat(cellValue) > parseFloat(filterValue);
                        case 'less':
                            return parseFloat(cellValue) < parseFloat(filterValue);
                        case 'notEmpty':
                            return cellValue.trim() !== '';
                        default:
                            return true;
                    }
                });
            });
        }

        function clearAllFilters() {
            AppState.filters = [];
            AppState.displayData = [...AppState.rawData];
            AppState.currentPage = 1;
            renderTable();
            closeFilterModal();
            showToast('All filters cleared', 'info');
        }

        function closeFilterModal() {
            document.getElementById('filterModal').classList.remove('active');
        }

        // Export
        function exportData() {
            const dataToExport = AppState.displayData.length > 0 ? AppState.displayData : AppState.rawData;
            
            let csv = AppState.columns.map(col => `"${col}"`).join(',') + '\n';
            
            dataToExport.forEach(row => {
                csv += AppState.columns.map(col => {
                    const value = row[col] || '';
                    return `"${String(value).replace(/"/g, '""')}"`;
                }).join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            
            link.href = url;
            link.download = `export_${new Date().toISOString().split('T')[0]}_${Date.now()}.csv`;
            link.click();
            
            URL.revokeObjectURL(url);
            showToast(`Exported ${dataToExport.length.toLocaleString()} rows`, 'success');
        }

        // Utility Functions
        function uploadNew() {
            if (confirm('Upload new data? Current data and visualizations will be replaced.')) {
                resetDashboard();
            }
        }

        function refreshData() {
            renderStats();
            renderTable();
            showToast('Data refreshed', 'info');
        }

        function resetDashboard() {
            AppState.rawData = [];
            AppState.displayData = [];
            AppState.columns = [];
            AppState.columnMetadata = {};
            AppState.currentPage = 1;
            AppState.sortConfig = { column: null, direction: 'asc' };
            AppState.filters = [];
            AppState.selectedChartColumns.clear();
            
            AppState.charts.forEach(chart => chart.destroy());
            AppState.charts = [];

            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('dashboardSection').classList.remove('active');
            document.getElementById('statusBadge').style.display = 'none';
            document.getElementById('chartsSection').style.display = 'none';
            document.getElementById('searchInput').value = '';
            document.getElementById('fileInput').value = '';

            showToast('Dashboard reset', 'info');
        }

        function showLoading(message, progress = 0) {
            document.getElementById('loadingOverlay').classList.add('active');
            document.getElementById('loadingText').textContent = message;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function updateProgress(percent, message) {
            document.getElementById('progressBar').style.width = percent + '%';
            if (message) {
                document.getElementById('loadingText').textContent = message;
            }
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('active');
        }

        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            const icon = document.getElementById('toastIcon');
            const messageEl = document.getElementById('toastMessage');

            const icons = {
                success: '‚úì',
                error: '‚úï',
                warning: '‚ö†',
                info: '‚Ñπ'
            };

            icon.textContent = icons[type] || icons.info;
            messageEl.textContent = message;
            toast.className = `toast ${type} active`;

            setTimeout(() => {
                toast.classList.remove('active');
            }, 4000);
        }
    </script>
</body>
</html>
